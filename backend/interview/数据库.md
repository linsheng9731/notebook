# b树、b+树

B Tree vs B+ Tree 的特点与应用，在某一个表中有一个字段 a，它的类型是整型，为 a 字段建立一个索引，请说出以下几个问题使用索引的情况：



# 查询 a != 10 时，是如何使用索引的？具体有哪些过程？为什么是这样 ？

# 当 a 的最大值为 100，查询 a > 100 是如何使用索引的？具体有哪些过程？为什么是这样？

# 同一个表中有字段 b, 类型是字符型，查询 a > 100 的 a, b 两个字段的值，请问这个查询可以再优化吗？怎么优化？为什么是这样？在什么情况下无法优化？


# 一条 sql 查询是如何执行的
客户端 - 连接器 - 缓存（mysql 8.0 已经取消了这个模块 因为缓存效率非常低） - 分析器 - 优化器 - 执行器 - 存储引擎
需要注意对表的权限操作是在执行器做的，有些关联的表操作比如触发器无法在词法分析阶段得到。

# 一条更新语句如何执行
和查询非常类似，在执行器层有所不同。
查询记录 - 判断是否在内存中 - 是否需要从磁盘中加载 - 更新值 - 写入 redo log（prepare 阶段） - 写入 binlog - 提交事务（处于 commit阶段）
redo log 是物理日志，是在 server 层的跟具体的存储引擎无关。redo log 主要记录页的状态变更。
binlog 是 innodb 引入的，主要记录逻辑变更。
日志写入需要两阶段提交，即写入 redolog 是prepare阶段，完成binlog写入后才会把修改提交。保证 redolog 和 binlog 的一致性。

# 索引
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

# 覆盖索引
如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。

# 最左前缀原则
B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是"where name like ‘张 %’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

# 索引下推
而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

# 索引选择原理
在第一篇文章中，我们就提到过，选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。
MySQL 是怎样得到索引的基数的呢？InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。
选择不准有几种可能：
1. 统计信息不准。统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。
2. 把回表和排序的消耗也统计进去了，不单单看扫描行数的多少。比如优化器选择使用索引 b，是因为它认为使用索引 b 可以避免排序（b 本身是索引，已经是有序的了，如果选择索引 b 的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。

另一种方法是，像我们第一个例子一样，采用 force index 强行选择一个索引。


# 为什么要是用自增主键
而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

