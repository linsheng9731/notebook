# 请说一下你对 DDD 的理解：

它主要解决什么样的问题？
传统业务开发围绕的是数据模型，根据数据库表结构进行面向过程编程。导致代码中充斥大量贫血对象，除了字段没有任何逻辑。
这违背了面向对象的思想，导致业务和开发沟通产生障碍。比如业务关心的是激活功能，但是开发看到的是怎么把数据库中 activated 字段更新为 true。DDD 是围绕业务领域进行建模，和面向对象的思想比较好契合。同时业务建模是和业务专家一起完成的，所以业务和开发沟通没有歧义。DDD提倡充血模式，把数据和对应的逻辑放在一起。这样能实现更好的单一职责、解耦、系统扩展性更强。

有哪些组成部分，与模式？
主要分 用户层 User Interface 负责向用户展现信息、应用层 Application Layer、领域模型层 Domain Layer、基础设施层 Infrastructure Layer。

你如何使用 DDD 解决具体的业务问题？


# CAP 理论，它们分布是什么？它们有哪些组合关系？这些组合关系具体有哪些应用场景？
CAP 指的是 一致性、可用性、分区容忍性。
CA 组合：一致切高可用，但是不能容忍网络分区。
CP 组合：一致且能容忍网络分区，但是系统可能不可用。
AP 组合：可用且能容忍分区，但是系统数据可能会不一致。

在追求性能的业务场景下一般选择 AP 组合，数据是最终一致。
在涉及财务的业务场景下追究一致性 C，可以是 CA 网络故障就停止服务，或者是 CP 网络故障只能读不能写。
ZK 选择 CP，如果发生网络故障集群中半数以上节点不可用则系统停止服务。但是能保证数据强一致，切部分节点不可用时服务正常。
Consul 选择 AP，集群中所有节点都是平等的。发生网络故障可以随意切换，不过每个节点的数据可能不是最新的。

你使用过的哪些系统多的是哪种组合模式？为什么选择它们？
一般是 AP 组合，只保障系统数据最终一致性。比如推送系统，任务投递后就直接返回了，后续是异步执行。如果某个实例发生网络故障数据可能会丢失，但是因为有多个实例服务不会挂。


# 请说一下无锁队列的设计

无锁队列的设计原理依据是什么？
CAS 指令、FAA（fetch and add）指令、Release 指令。
Java 并发包中基于链表实现的无锁队列，ConcurrentLinkedQueue。主要在修改指针的时候使用 CAS （retry-loop）方式进行设置。
会存在 ABA 问题，即 a->b->a ，基本解决思路是添加版本。每次执行 CAS 操作版本加一，对比的时候同时对比内容和版本。

有哪些受限的场景？
涉及到链表的插入移除读写性能一般，节点生产和消费可能会造成频繁 gc
基于数组实现无锁队列，RingBuffer，环形数组，一次性申请内存，循环使用避免 gc。连续的内存空间地址使得消费性能更高，因为cpu会在读一个元素的时候把相邻的元素也读出来，提高了命中率。Disruptor 还进行了内存填充，避免伪共享问题。

你是如何使用它们的？为什么要使用它们？给你带来了哪些好处与坏处？
在多生产者-多消费者模型下可以使用无锁队列，因为生产者和消费者有多个所以需要一个线程安全的队列结构。


# raft 协议
三种状态：
- follower
- candidate
- leader

每个节点都维护一个递增的 term。
开始选举，每个节点随机等待一段时间。
开始选举自己为 leader，向其他节点发起选举请求。
收到比自己 term 大的请求，放弃选举，改为 follower。

脑裂问题：引入 region leader 的概念，允许部分

# 全局递增 id


