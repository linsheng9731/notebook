# 如何合理设置线程池大小
线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。

（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换
（2）并发不高、任务执行时间长的业务要区分开看：
　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务
　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换
（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。


# ThreadLocal
Thread 持有 threadlocalMap 变量，map 的 key 为 threadlocal，value 为设置的值。
这么做是为了避免内存泄露，因为 thread 生命周期可能很短，如果 threadlocal 的 key 是 thread，那么只要 threadlocal 不被回收，thread 就不会被垃圾回收造成内存泄露。
threadlocalMap 的 entry中的 key（threadlocal） 是弱引用，弱引用只要进行垃圾回收就会被回收，所以使用 threadlocal 的时候会有一个强引用和一个弱引用，如果线程中不再使用这个变量，强引用就会断开只剩一个弱引用，gc的时候就会被回收避免内存泄露。
但是 entry 中的 value 是强引用，如果使用的是线程池，thread 是一直存在的，会存在一条强引用链：thread - threadlocalmap - entry - value 所以使用 threadlocal 需要 try... finall{ remove } 手动回收。


# CAS 乐观锁

# 分布式锁


# Actor 模型


# CSP 模型


# Java 并发工具

# Java 并发容器


请你描述一下你对多线程的理解，可以从这三个方面：

什么是多线程？

多线程解决什么问题？

多线程在什么样的情况下会出现哪些问题？

如何解决这些问题？

除了使用 同步/锁 的方式，有哪些方法能解决并发读写问题？

使用多进程能到达多核利用，提升效率的目的吗？

如果能，那为什么要使用多线程达到上述目的？

如果能，怎么解决数据共享？有哪些进程间的通讯手段？它们各自的特点是什么？

如果不能，请说明为什么不能？

# 说说你熟练掌握的几种多线程模式？分别用它们解决什么问题？性能怎么样？
