## 问：以下两种代码，在运行时有什么不同？为什么？
第一种:
```
private static final boolean isLoggerDebugEnabled = log.isDebugEnabled();
public void xx(User user){
     if(isLoggerDebugEnabled){
          log.debug("enter xx method, user id is: " + user.getId());
     }
}
```
第二种:
```
public void xx(User user){
     log.debug("enter xx method, user id is: " + user.getId());
}
```

答：如果log的debug级别没开，第一种不会出现字符串拼接，第二种会出现，造成一些young区的内存浪费，所以第一种写法是更加好的，原因是第一种在Java运行时的编译过程中会直接优化掉，整段代码会彻底拿掉。

## 问：有哪些编译器优化？

答：
早期（编译期）优化：
泛型与类型擦除
自动装箱、拆箱与遍历循环
条件编译（去掉不会运行的代码）

晚期（运行期）优化：
分层编译策略；分层编译策略作为默认编译策略在JDK1.7的Server模式虚拟机中被开启，其中包括：
第0层：程序解释执行，解释器不开启性能监控功能，可触发第1层编译；
第1层：C1编译，将字节码编译成本地代码，进行简单可靠的优化，如有必要将加入性能监控的逻辑；
第2层：C2编译，也是将字节码编译成本地代码，但是会启动一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。
实施分层编译后，C1和C2将会同时工作，C1获取更高的编译速度，C2获取更好的编译质量，在解释执行的时候也无须再承担性能监控信息的任务。  

热点代码探测
在运行过程中会被即时编译器编译的“热点代码”有两类：
1.被多次调用的方法：由方法调用触发的编译，属于JIT编译方式
2.被多次执行的循环体：也以整个方法作为编译对象，因为编译发生在方法执行过程中，因此成为栈上替换（OSR编译）

公共子表达式消除
如果一个表达式E已经计算过了，并且先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共表达式，可以直接用之前的结果替换。

数组边界检查消除
编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组长度以内，那么整个循环中就可以把上下界检查消除，这样可以省很多次的条件判断操作。

方法内联

逃逸分析
当一个对象被外部方法所引用，称为方法逃逸；当被外部线程访问，称为线程逃逸。若能证明一个对象不会被外部方法或进程引用，则可以为这个变量进行一些优化：
栈上分配：如果确定一个对象不会逃逸，则可以让它分配在栈上，对象所占用的内存空间就可以随栈帧出栈而销毁。这样可以减小垃圾收集系统的压力。  
2.同步消除：线程同步相对耗时，如果确定一个变量不会逃逸出线程，那这个变量的读写不会有竞争，则对这个变量实施的同步措施也就可以消除掉。  
3.标量替换：如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那么程序真正执行的时候可以不创建这个对象，改为直接创建它的成员变量，这样就可以在栈上分配。